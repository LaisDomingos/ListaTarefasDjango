CRIAR AMBIENTE VISUAL:

Para criar um ambiente virtual, no terminal do VS code: python -m venv .venv -> Cria uma pasta de gerenciamento, o segundo venv é o nome da pasta, normalmente se usa esse nome.
Essa pasta é onde vai ficar as bibliotecas.
Precisamos ativar esse ambiente e para isso, no terminal: .\.venv\Scripts\activate, quando fazemos isso, tudo que isntalarmos vai ser colocado nesta pasta venv  
Instalamos o django: pip install django


EXPLICAÇÃO DE CADA PARTE DO PROJETO:

manage.py -> carrega todos os módulos de configuração do django
setup -> pasta inicial do projeto
	settings.py -> configuraçãos: apps usados, linguagem, banco de dados, templates
	urls.py -> arquivo principal de rotas
	wsgi.py -> padrão do python, explica como um projeto python tem conexão com o servidor 
	asgi.py -> serve para o mesmo que wsgi, mas para aplicações assincronas.
pastas de app -> pasta dos apps
	admin.py -> arquivo de configuração do admin que o próprio django entrega por completo 
	apps.py -> configuração especifica da app criada
	models.py -> modelos da app 
	tests.py -> testes automatizado para aquela app
	views.py -> camada de views
	migrations -> fica as migrações dos models

Django usa o MTV -> model, templates, views
	Model -> Base de dados, classes python 
	Templates -> Camada de visualizção dos dados, interação dos usuários
	Views -> Ligação entre Model e Templates, o que tem que ser feito quando a requisição foi feita

Apps: gerenciamento de cliente, gerenciamento de produtos...
Projeto: conjunto de apps


CRIAR PROJETO:

Uma pratica que alguns tem é criar com o nome setup
No terminal: django-admin startproject setup . -> Esse ponto é para que ele não crie uma segunda pasta, já que já possui o twtodos. Ele vai criar a pasta setup, mas o ficheiro manage.py fica no diretório principal
Iniciar o projeto: python manage.py runserver
	Posso abrir pelo link que dá no terminal ou por localhost:8000

Em settings.py podemos configurar a linguagem do código e a zona.

CRIAR APP:
 
No terminal:django-admin startapp todos [to do (s) - explicando o nome]
Temos que instalar a app no settings, o objetivo é que a app seja reutilizável, então pode instalar e desistanlar: coloco uma string com o nome da app ou podemos colocar o caminho completo - todos.apps.TodosConfig (esse TodosConfig foi tirado do ficheiro apps.py que vem configurado já)
 
Em views, criamos funções do que precisa ser feito quando uma requisição foi feita.
Views: 
from django.shortcuts import render

def home(request):
    return render (request, "todos/home.html")


Em url.py podemos importa tudo de uma vez, nome da app import views, ou cada função: from todos.views import home, qunado usamos a segunda maneira, ao criar a rota só colocamos path('', home), já na primeira maneira: path('', views.home)


CRIAR MODELS:

Quando criamos models, criamos classes e elas por padrão precisam herda de models:
class Todo(models.Model):
	title = models.CharField(max_length=100, null=False, blank=False) -> Não pode ser nulo e não pode ser em branco, ou seja, somente espaços
	created_at = models.DateTimeField(auto_now_add=True, null=False, blank=False) -> Recebe a data e hora automaticamente, sem precisar ser preenchida
	deadline = models.DateField(null=False, blank=False) -> Só a data
    finished_at = models.DateField(null=True)


Para transforma a classe em banco de dados precisa ir no terminal e colocar: python .\manage.py migrate, mas asism não cria a nossa base de dados, ele apenas cria as migrates do próprio django. Então precisamos criar o nosso: python manage.py makemigrations, e assim cria um ficheiro na pasta migrations onde tem as informações.
Assim executar o comando anterior novamente, o nome do banco fica o nome da app_model

Se eu faço alguma alteração tem que criar a migração:  python manage.py makemigrations, quando fazemos uma nova mudança cria um novo ficheiro em migrations que contém as mudanças


CONFIGURAÇÕES INTERESSANTES:

Na configuração tem Secret_Key e de boa prática não deve ficar exposta dessa maneira, podemos fazer de várias maneiras, uma delas é por uma biblioteca, para isso:
Instalar: pip install python-decouple
Na parte inicial do projeto criar um ficheiro chamado .env
Copiar o Secret_key do settings e colocar em .env, sem as aspas
Em settings, importa: from decouple import config
E secret_key fica: SECRET_KEY = config('SECRET_KEY') -> SECRET_KEY sendo o nome que colocou em .env
Faço o mesmo com o Debug, coloco no .env e chamo em settings: DEBUG = config('DEBUG', cast=bool, default=False) -> vem como uma string, então uso cast para passar para boll e caso esteja vazio defino como false
Faço o mesmo com ALlowed_Hosts, mas esse em .env coloco: ALLOWED_HOSTS = * pq ele não aceita lista, e na hora de importa o config, tenho que colocar também ", Csv" para ele transformar em lista e na hora de chamar: ALLOWED_HOSTS = config('ALLOWED_HOSTS', cast=Csv())

Podemos também isolar a configuração de dados em um arquivo:
Para isso precisamos instalar uma biblioteca que faz uma conversão especifica para o Django "pip install dj-database-url"
Temos que fazer a importação from dj-database-url import parse as db_url -> esse parse é um apelido para chamar
Em settings tem uma parte de DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}, devemos apagar o default inteiro e passar para:
DATABASES = {
    'default': config("DATABASE_URL", default =f'sqlite:///{BASE_DIR / "db.sqlite3" }', cast=db_url)
}
Não precisamos, nesse caso colocar no .env pq já uso o default
 
PADRONIZAÇÃO DE CÓDIGO:

Instalar biblioteca : pip install black para fazer a auto fomatação do código
No terminal coloco balack ., assim ele faz a identação
Mas para que fique automatico: CTRL + SHIFT + p
Procuro por Preferences: Open Workspace Settings (JSON) -> colocar na barra de procura setting e vai abrir um ficheiro:
settings.json que colocamos 
	{
    "editor.formatOnSave": true,
    "python.formatting.provider": "black",
    "editor.defaultFormatter": "ms-python.black-formatter"
}

Ele automaticamente faria a identação, mas no meu caso não funcionou, mas se eu colocar no terminal: black ., isso é feito (isso no settings.py)


PÁGINA DE LISTAGEM DE TAREFAS:

Criamos um todo_list.html dentro de templates e ignoramos o anterior, chamado home.html
Como vamos usar configurações/sinteses do Django, vamos instalar um pluggin do VS Code, chamado Django (é do Baptiste Darthenay)
Ai podemos definir o todo_list.html como um arquivo django-html, posso automatizar naquele settings.json, acrescentando essa linha:
"files.associations": {
 	"**/templates/**/*.html": "django-html"
 }, 

acrescentamos também essa linha para que ele entenda que ainda é html:
"emmet.includeLanguages": {
        "django-html": "html"
    }

Em views precisamos buscar as informações na base de dados para que mostre, e para isso além da renderização da página tem que passar o que ta sendo enviado, no caso um dicionário python. Exemplo:
def todo_list(request):
    nome = "Laís"
    return render(request, "todos/todo_list.html", {"nome": nome})

E para exibir, vou em todo_list.html:
<h1>Lista de Tarefas</h1>
{{ nome }}


Posso fazer o mesmo para uma lista:
def todo_list(request):
    nome = "Laís"
    alunos = ["Wally", "Viego", "Morgana"]
    return render(request, "todos/todo_list.html", {"nome": nome, "alunos" : alunos})

<ul>
    {% for aluno in alunos %}
        <li>{{ aluno }}</li>
    {% endfor %}
</ul>

Não deve esquecer de colocar a rota em url


BUSCAR OS DADOS NO BANCO DE DADOS POR MEIO DA VIEWS:

Temos que importa o models: from .models import Todo -> Nome do model
Criamos uma variável que possui o objeto para fazer a manipulação:
def todo_list(request):
    todos = Todo.objects.all() -> all para pegar tudo
    return render(request, "todos/todo_list.html", {"todos": todos})

Aqui quero mostrar só o title, no html posso fazer dessa maneira, lembrando que o title é o nome de uma coluna no model:
	<h1>Lista de Tarefas</h1>
<ul>
    {% for todo in todos %}
        <li>{{ todo.title }}</li>
    {% endfor %}
</ul>

Ele não colocou id, mas se eu colocar: {{ todo.id }} ou {{ todo.pk }} vai aparacer o id

<td>{{ todo.finished_at }}</td> -> esse valor pode esta vazio, então ele vai ficar como none, para tirar isso podemos usar um filtro do django e assim coloco o default: <td>{{ todo.finished_at|default:"-" }}</td>

Posso usar If e Else:
{% if todos %}
        <table class="table">
            <thead>
              <tr>
                <th scope="col">#</th>
                <th scope="col">Título</th>
                <th scope="col">Criado em</th>
                <th scope="col">Data de entrega</th>
                <th scope="col">Data de finalização</th>
                <th scope="col">Ações</th>
              </tr>
            </thead>
            <tbody>
                {% for todo in todos  %}
                <tr>
                    <th scope="row">{{ todo.pk }}</th>
                    <td>{{ todo.title }}</td>
                    <td>{{ todo.created_at }}</td>
                    <td>{{ todo.deadline }}</td>
                    <td>{{ todo.finished_at|default:"-" }}</td>
                    <td>
                        <a href="#" class="btn btn-primary btn-sm">Concluir</a>
                        <a href="#" class="btn btn-danger btn-sm" >Excluir</a>
                    </td>
                </tr>
                {% endfor %}
              
            </tbody>
        </table>
        {% else %}
            <p>Não há tarefas cadastradas</p>
        {% endif %}
Se tiver dados mostra a tabela, se não mostra o p:
{% if todos %}
{% else %}
{% endif %}

PARA INSERIR DADOS MANUALMENTE:

Instalar MySQL pelo VS, deve ser o que tem a cor laranja e azul(desenvolvido pelo Weijan Chen)
Aparece um database na barra lateral, clico nele
Clico em create connection, procura o SQLite [precisa instalar e não consigo istalar]


FBV - FUNCTION-BASED VIEW E CBV - CLASS BASED VIEW:

O recomendado é usar CBV. A função que usamos em todo_list é uma FBV e vamos altera-la.

Quando usamos CBV o código fica mais organizado, da pra reutilizar códigos e automatizar. Para funções como inserir, editar e deletar, já possui classes para isso.


LISTAGEM DE DADOS USANDO CBV - CLASS BASED VIEW:

Em view importamos: from django.views.generic import ListView.

E ao invés da função: def todo_list(request):
    todos = Todo.objects.all()
    return render(request, "todos/todo_list.html", {"todos": todos}), usamos o ListView:
class TodoListView (ListView):
    model = Todo

Na url ao invés de importa todo_list, importamos TodoListView e a rota fica seguinte maneira:  path("", TodoListView.as_view())
Também temos que alterar no html todos os "todos" para "todo_list", ele já procura o nome todo e acrescenta _list


REGISTRAR USANDO CBV - CLASS BASED VIEW:

Em view, além de importa ListView tempos que importa CreatView que faz parte do pacote django.views.generic  como o ListView. E criamos a CBV:
class TodoCrateView(CreateView):
    model = Todo
    fields = ["title", "deadline"] -> São os dados que precisam ser preenchidos, no nosso caso são só esses, pois o restante é automatico e o outro só quando for concluído

Criamos uma nova rota: path("create", TodoCrateView.as_view()),

Crio uma página html com: todo_form.html, o nome também é padronizado. Ao ir em http://localhost:8000/create, vai aparecer a configuração que fiz no html. 

Quando criamos o fields, ele já cria uma classe de formulário que envia para a template, então no html posso chamar: {{ form }}, e nesse caso cria dois campos, um para title e outro para deadline. Para que fique melhor, colocamos em uma tag form e criamos um button:
<form method="POST">
          {{ form }}

          <button type="submit"> Salvar </button>
        </form>
Usando esse form, ele já coloca que não foi preenchidos e se foi preenchido com o tipo de dado errado

CSRF: Uma das seguranças que o django inclementa, é um ataque, então para evitar esse ataque, ele cria um input invisivel com uma chave que django sabe que não é outro site fazendo a requisição.

Então para evitar esse ataque, toda vez que criamos um formulário precisamos colocar dentro do form: {% csrf_token %}

Quando utiliza o CreateView, ele tem que saber pra onde ele vai quando o cadastro é feito com sucesso
- Para isso temos que colocar nomes nas rotas: path("", TodoListView.as_view(), name="todo_list"), 
    path("create", TodoCrateView.as_view(), name="todo_create") -> Com isso posso fazer referência a essas rotas usando o name
- Importamos em views.py: from django.urls import reverse_lazy -> quando passamos o nome da rota, ele mesmo passa a rota completa a parti do nome
- E acrescentamos na função TodoCrateView(CreateView):
	 success_url = reverse_lazy("todo_list")

Podemos agora em todo_list.html, criar link que chama para aquela página de cadastrar tarefa, e para isso também utilizamos o name: <a href="{% url 'todo_create' %}" class="btn btn-primary">Nova Tarefa</a>


FORMATAÇÃO DO {{ FORM }} SEM RENDERIZAÇÃO:

Vamos usar uma biblioteca crispy para que possamos formatar o {{ form }} sem termos que renderizar e assim conseguimos estilizar, nesse crispy há a possibilidade de formatarmos com o crispy
No terminal: pip install crispy-bootstrap5
Precisamos fazer uma instalação no settings:
"crispy_forms",
"crispy_bootstrap5",

Também temos que colocar isso em settings:
CRISPY_ALLOWED_TEMPLATE_PACKS = "bootstrap5"

CRISPY_TEMPLATE_PACK = "bootstrap5"

A partir disso colcamos {% load crispy_forms_tags %} no inicio do html todo_form.html, e o main fica da seguinte maneira:
<main class="container">
        <h1>Nova Tarefa</h1>
        <form method="POST">
          {% csrf_token %}
          {{ form | crispy }}
          <button type="submit" class = "btn btn-primary"> Salvar </button>
	</form>
        
    </main>

Os nomes dos inputs, fica como está na base de dados, mas está em inglês e não é isso que queremos, por isso que passar uma configuração a mais no models:
title = models.CharField(verbose_name="Título", max_length=100, null=False, blank=False)
deadline = models.DateField(verbose_name="Data de Entrega", null=False, blank=False)-> Utilizamos o verbose_name e colocamos o nome que queremos que apareça


ORGANIZAR INSTALAÇÕES:

Podemos criar array e só chama-los nas instalações:
DJANGO_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]

THIRD_PARTY_APPS = [
    "crispy_forms",
    "crispy_bootstrap5",]

MY_APPS = [
    "todos.apps.TodosConfig",
]

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + MY_APPS


REAPROVEITAMENTO DE CÓDIGO - HERANÇA DE TEMPLATES:

Crio um html base, na pasta templates, nela vamos colocar tudo que é comum em todas as páginas, isso inclui também as tags padrões do html e onde terá conteudo diferente coloco {% block nome_que_eu_quiser %} {% endblock nome_que_eu_quiser %}, posso colocar vários desse

Na página que vai herdar esse template coloco: {% extends "base.html" %} e colocamos todo o conteúdo dentro {% block nome_que_eu_quiser %} {% endblock nome_que_eu_quiser %}, sendo o nome que está em base.html

Se forem em blocos diferentes, só abrir outro block e colocar o nome

No caso de todo_form, o {% load crispy_forms_tags %}, fica após o extends


EDITAR USANDO CBV - CLASS BASED VIEW:

No view.py, precisamos importa UpdateView que é da mesma biblioteca de ListView, CreateView.
A class TodoUpdateView é igual a de criação, a diferença é que ele vai procurar um id especifico:
class TodoUpdateView(UpdateView):
    model = Todo
    fields = ["title", "deadline"]
    success_url = reverse_lazy("todo_list")

Não podemos esquecer de fazer a rota em url, mas dessa vez a rota vai ter um parametro que no caso vai ser o ID, por padrão o UpdateView ele vai procurar a variável pk, então na rota colocamos o tipo e o nome da variável (pk):
path("update/<int:>", TodoUpdateView.as_view(), name="todo_update"),
Assim já consigo ir no localhost e colocar localhost:8000/update/um_id e já consigo editar.

Em todo_form, devo colocar um if para caso tenha o pk apareça um Editar Tarefa, desta maneira:
{% extends "base.html" %}

{% load crispy_forms_tags %}

{% block page_title %} 
  {% if todo.pk %}
    Editar Tarefa
  {% else %}
    Nova Tarefa
  {% endif %}
{% endblock page_title %}

{% block content %}
  {% if todo.pk %}
    <h1>Editar Tarefa</h1>
  {% else %}
    <h1>Nova Tarefa</h1>
  {% endif %}
  <form method="POST">
    {% csrf_token %}
    {{ form | crispy }}
    <button type="submit" class = "btn btn-primary"> Salvar </button>
  </form>
{% endblock content %}

Em todo_list.html, criamos um link para Editar e chamar essa página, mas precisa passar o pk também, e para isso passamos da seguinte maneira: <a href="{% url  'todo_update' pk=todo.pk %}" class="btn btn-secondary btn-sm" >Editar</a>
Esse todo.pk é por causa do for


EXCLUSÃO USANDO CBV - CLASS BASED VIEW:

No view.py, precisamos importa DeleteView que é da mesma biblioteca de ListView, CreateView,UpdateView
Criamos uma rota em url, a rota também recebe id: path("delete/<int:pk>", TodoDeleteView.as_view(), name="todo_delete"),
Colocmos o link de excluir: <a href="{% url  'todo_delete' pk=todo.pk %}" class="btn btn-danger btn-sm" >Excluir</a>

Precisamos criar um template de confirmação de exclusão que é solicitado pelo DeleteView, o template tem que ter:nomedomodelo_confirm_delete, no nosso caso todo_confirm_delete.
Nesse template, alé da extensão de base.html, temos que ter um form, com method POSTO, logo tem que ter o {% csrf_token %}

<form action="POST">
        {% csrf_token %}

        <button type="submit" class="btn btn-danger">Excluir</button>
        <a href="{% url 'todo_list' %}" class="btn btn-primary">Cancelar</a>
    </form>
Caso cancele volta para a lista de tarefas e se Excluir vai passar uma rota com o POST

A classe deve ser assim:
class TodoDeleteView(DeleteView):
    model = Todo
    success_url = reverse_lazy("todo_list")


CRIAR PÁGINA DE CONCLUSÃO

Em models, o finished_at está vazio e quando aperta em conclusão queremos apenas que essse campo seja preenchido.
Nesse caso não terá um view do django para fazer isso, mas usaremos o View para transformar em um CBV. Para isso, temos que importa View da mesma biblioteca do restante 

Para criar a classe, vamos criar os métodos post e get.
O Get recebe dois parametros, um é que todas as funções em class recebe que é o self e outro é o request

